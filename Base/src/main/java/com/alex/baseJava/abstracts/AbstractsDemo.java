package com.alex.baseJava.abstracts;


//如果一个类包含抽象方法，那么该类必须是抽象类。
//继承抽象类的子类必须重写父类所有的抽象方法。否则，该子类也必须声明为抽象类。
// 最终，必须有子类实现该父 类的抽象方法，否则，从最初的父类到最终的子类都不能创建对象，失去意义。
abstract class abstracttest {
    protected int a = 45;
    public abstracttest() {
        this.a=454;
    }
    public abstract void run();
}
class a extends abstracttest{
    public a(){
        super();
    }

    @Override
    public void run() {
        System.out.println("继承抽象类的子类必须重写父类所有的抽象方法"+a);
    }
}

//1. 抽象类不能创建对象，如果创建，编译无法通过而报错。只能创建其非抽象子类的对象。 理解：假设创建了抽象类的对象，调用抽象的方法，而抽象方法没有具体的方法体，没有意义。
//2. 抽象类中，可以有构造方法，是供子类创建对象时，初始化父类成员使用的。 理解：子类的构造方法中，有默认的super()， 需要访问父类构造方法。 3. 抽象类中，不一定包含抽象方法，但是有抽象方法的类必定是抽象类。
//3. 抽象类中，不一定包含抽象方法，但是有抽象方法的类必定是抽象类。理解：未包含抽象方法的抽象类，目的就是不想让调用者创建该类对象，通常用于某些特殊的类结构设 计。
//4  抽象类的子类，必须重写抽象父类中所有的抽象方法，否则，编译无法通过而报错。除非该子类也是抽象类 理解：假设不重写所有抽象方法，则类中可能包含抽象方法。那么创建对象后，调用抽象的方法，没有 意义。



public class AbstractsDemo{
    public static void main(String[] args) {
        //当使用多态方式调用方法时，首先检查父类中是否有该方法，如果没有，则编译错误；如果有，执行的是子类重写后方法。


        //实际开发的过程中，父类类型作为方法形式参数，传递子类对象给方法，进行方法的调用，更能体现出多态的扩展 性与便利。
        abstracttest a1 = new a();
        a1.run();
    }
}
